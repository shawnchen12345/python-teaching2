# Day 2: 数据结构与核心优势 (详细讲义)

**课程时长**: 4-5 小时
**教学目标**: 深入理解 Python 在数据处理方面的天然优势，掌握列表、字典、字符串的底层逻辑与高级用法。

---

## 第一部分：为什么选择 Python？ (0.5 小时)

### 1.1 Python vs 其他语言
在开始学习复杂数据结构前，我们先看一眼“外面的世界”，你才会知道 Python 有多香。

#### 对比 1: "Hello World" 之后的数组
*   **C 语言**: 需要手动申请内存，还得小心内存泄漏。数组一旦定义，长度通常固定。
*   **Java**: `ArrayList<String> list = new ArrayList<>();` (写起来很啰嗦)。
*   **Python**: `lst = []` (一秒搞定)。
    *   **优势**: Python 的列表是**动态数组**，它是“会呼吸的”，随时伸缩，且能装任何东西（整数、字符串、甚至另一个列表）。

#### 对比 2: 交换两个变量
*   **C/Java**: 需要一个中间变量 `temp`。
    ```java
    int temp = a; a = b; b = temp;
    ```
*   **Python**: packing/unpacking 魔法。
    ```python
    a, b = b, a
    ```

#### 对比 3: 哲学差异
*   **C++**: "相信程序员，让他控制一切（包括炸掉内存）"。
*   **Java**: "不相信程序员，用繁琐的规则限制你，防止你犯错"。
*   **Python**: "相信程序员是成年人，人生苦短，我用 Python"。

### 1.2 Python 的“胶水”特性与数据生态
为什么数据分析（Data Science）和 AI 都选 Python？
*   **底层快**: Python 语法慢，但底层库（NumPy, Pandas）是用 C 写的，Python 只是指挥官。
*   **语法甜**: 处理字符串、字典极其顺手，被誉为“**可执行的伪代码**”。

### 1.3 为什么要学习数据结构？
数据结构是计算机存储、组织数据的方式。如果不学数据结构，你就只是在“写代码”，而不是“设计程序”。

*   **决定程序的效率**
    *   想象你在图书馆找一本书。如果书是**乱堆**在地上的（无结构），你可能要找一天。如果书是按**索引分类**摆放的（有序结构），你只要几分钟。
    *   *案例*: 在 1000 万用户中查找某个 ID。用列表遍历可能要几秒甚至几分钟（如果不凑巧），用字典（Hash）只需要 0.0001 秒。**量级越大，差异越夸张**。
*   **建模现实世界**
    *   现实中的问题通常都有特定的结构。
    *   **排队** -> **队列** (First In First Out)。
    *   **撤销操作 (Ctrl+Z)** -> **栈** (Last In First Out)。
    *   **家族族谱** -> **树**。
    *   **地图导航** -> **图**。
*   **面试与进阶的基石**
    *   所有大厂面试必问数据结构。因为它是程序员的“内功”，决定了你上限在哪里。

> **核心心法**: 程序 = 数据结构 + 算法。Python 已经内置了最强大的几种数据结构（列表、字典、集合），我们要学会的是**在什么场景下选择哪种武器**。


---

## 第二部分：列表 List (1.5 小时)

### 2.1 列表 (List) - Python 的“瑞士军刀”
Python 的列表不仅仅是数组，它是一个功能强大的动态容器。你可以把它理解为**智能变长数组**。

#### 1. 核心特性
*   **有序 (Ordered)**: 元素怎么放进去，就怎么排着（除非你排序）。可以通过索引 `[0]` 访问。
*   **可变 (Mutable)**: 你可以随时在这个容器里增加、删除、修改元素。（这点和字符串不同！）
*   **异构 (Heterogeneous)**: 一个列表里可以同时装整数、字符串，甚至另一个列表。
    *   `my_list = [100, "Python", [1, 2]]`

#### 2. 基础语法速查 (Syntactic Sugar)
```python
# 1. 创建 - 就像去超市拿个空篮子
empty = []        
numbers = [10, 20, 30, 40, 50]

# 2. 索引 (Indexing) - 查单人
print(numbers[0])    # 10 (第一个)
print(numbers[-1])   # 50 (倒数第一个，Python 特有福利)

# 3. 切片 (Slicing) - 查一批人 [开始:结束:步长]
print(numbers[1:4])  # [20, 30, 40] (包头不包尾)
print(numbers[::-1]) # [50, 40, 30, 20, 10] (直接翻转，面试常考)

# 4. 修改
numbers[0] = 999     # [999, 20, ...]

# 5. 常用方法
numbers.append(60)   # 尾部追加
numbers.pop()        # 弹出最后一个
len(numbers)         # 长度
```

### 2.2 内存模型图解 (重要！)
在 Python 中，`a = [1, 2, 3]` 到底发生了什么？
*   **变量名 `a`**: 是一张便利贴（引用）。
*   **列表对象 `[...]`**: 是内存里的一个集装箱。
*   **元素 `1, 2`**: 也是独立的内存对象。列表里存的其实是这些对象的“地址指针”。

**深浅拷贝的坑**:
```python
a = [1, 2, 3]
b = a        # 只是贴了新标签，也没复制箱子
b[0] = 999
print(a)     # [999, 2, 3] -> a 也变了！

# 正确复制 (切片)
c = a[:]     # 咱们买个新箱子，把里面的东西抄过来
```

### 2.3 列表的增删改查 (CRUD) 性能分析
*   **Append (尾部添加)**: 极其快 (O(1))。
*   **Insert (中间插入)**: 非常慢 (O(N))。因为要把插入点后面的所有人都往后挪一位。 

    *   *教学建议*: 尽量避免在长列表的头部插入数据。

### 2.4 列表推导式 (List Comprehension)
这是 Python 最优雅的特性之一。
```python
# 任务: 找出 1-100 里的偶数，并把它们平方
# 旧写法 (4行)
res = []
for i in range(1, 101):
    if i % 2 == 0:
        res.append(i ** 2)

# Pythonic 写法 (1行)
res = [i**2 for i in range(1, 101) if i % 2 == 0]
```

---

## 第三部分：字符串 String (1 小时)

### 3.1 字符串不可变 (Immutable) 的秘密
`s = "hello"`
`s[0] = "H"` ❌ 报错！
*   **为什么设计成不可变？**
    1.  **安全**: 可以放心地把字符串传给函数，不用担心被改坏。
    2.  **效率**: 同样的字符串 "hello" 在内存里只有一份（字符串驻留机制），节省内存。

### 3.2 字符串处理三剑客
1.  **Split & Join** (拆分与缝合):
    *   `tags = "python,ai,bigdata"`
    *   `lst = tags.split(",")` -> `['python', 'ai', 'bigdata']`
    *   `"#".join(lst)` -> `"python#ai#bigdata"`
2.  **Strip** (去皮):
    *   `"  admin  ".strip()` 用来处理用户糟糕的输入。
3.  **Format** (格式化):
    *   `f"Hey {name}, score: {score:.1f}"`

---

## 第四部分：字典 Dictionary (1 小时)

### 4.1 哈希表 (Hash Map) 原理
字典为什么快？
*   **列表查找**: 像一本没有目录的书，找“张三”得一页页翻 (O(N))。
*   **字典查找**: 有目录，直接算出“张三”在哪一页 (O(1))。无论字典有一万条还是一亿条数据，查找速度几乎一样快！

### 4.2 常用操作
```python
student = {"name": "Tony", "score": 98}

# 1. 安全取值
# print(student["age"]) -> 报错 KeyError
print(student.get("age", 18)) -> 没 age 就默认 18

# 2. 遍历
for k, v in student.items():
    print(k, v)
```

### 4.3 什么时候用字典？什么时候用列表？
*   **有序、重复数据** -> 列表 (如：过去10天的气温)。
*   **映射关系、属性数据** -> 字典 (如：身份证号->人，商品ID->价格)。

---

## 第五部分：元组与集合 (0.5 小时)

### 5.1 元组 (Tuple) - 戴手铐的列表
`t = (1, 2)`
*   **场景**: 
    1.  经纬度 `(39.9, 116.4)`，不应该被修改。
    2.  字典的 Key 必须是不可变的，所以列表不能当 Key，但元组可以。

### 5.2 集合 (Set) - 数学工具
`s = {1, 2, 3}`
*   **秒杀面试题**: "给列表去重"。
    `unique_lst = list(set(old_lst))`
*   **关系运算**: 交集 `&`，并集 `|`，差集 `-`。

---

## 第六部分：实战项目 - 简易学生管理系统 V2.0 (1 小时)

### 6.1 需求升级
V1.0 只是简单的打印。V2.0 我们要求：
*   **数据结构**: 使用 `[{"name": "A", "age": 18}, ...]` 列表嵌套字典。
*   **持久化**: (预告 Day 5) 现在先存在内存变量里。
*   **交互**: 命令行菜单。

### 6.2 伪代码逻辑
```python
students = []

while True:
    print("""
    1. Add Student
    2. Delete Student
    3. Find Student
    4. List All
    5. Exit
    """)
    choice = input("Select: ")
    
    if choice == "1":
        # Input name, age
        # Create dict, append to students
        pass
    elif choice == "2":
        # Input name
        # Loop students, if name matches, remove
        # 注意: 循环中删除列表元素是大坑！建议用新列表覆盖或倒序循环
        pass
```
*   **关键点**: 在写删除逻辑时，引导学生发现 `for s in students: students.remove(s)` 会导致跳过元素的 Bug，引出“倒序删除”或“建立新列表”的正确解法。
