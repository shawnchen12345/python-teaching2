# Day 2: 数据结构与核心优势 (详细讲义)

**课程时长**: 4-5 小时
**教学目标**: 深入理解 Python 在数据处理方面的天然优势，掌握列表、字典、字符串的底层逻辑与高级用法。

---

## 第一部分：为什么选择 Python？ (0.5 小时)

### 1.1 Python vs 其他语言
在开始学习复杂数据结构前，我们先看一眼“外面的世界”，你才会知道 Python 有多香。

#### 对比 1: "Hello World" 之后的数组
*   **C 语言**: 需要手动申请内存，还得小心内存泄漏。数组一旦定义，长度通常固定。
*   **Java**: `ArrayList<String> list = new ArrayList<>();` (写起来很啰嗦)。
*   **Python**: `lst = []` (一秒搞定)。
    *   **优势**: Python 的列表是**动态数组**，它是“会呼吸的”，随时伸缩，且能装任何东西（整数、字符串、甚至另一个列表）。

#### 对比 2: 交换两个变量
*   **C/Java**: 需要一个中间变量 `temp`。
    ```java
    int temp = a; a = b; b = temp;
    ```
*   **Python**: packing/unpacking 魔法。
    ```python
    a, b = b, a
    ```

#### 对比 3: 哲学差异
*   **C++**: "相信程序员，让他控制一切（包括炸掉内存）"。
*   **Java**: "不相信程序员，用繁琐的规则限制你，防止你犯错"。
*   **Python**: "相信程序员是成年人，人生苦短，我用 Python"。

### 1.2 Python 的“胶水”特性与数据生态
为什么数据分析（Data Science）和 AI 都选 Python？
*   **底层快**: Python 语法慢，但底层库（NumPy, Pandas）是用 C 写的，Python 只是指挥官。
*   **语法甜**: 处理字符串、字典极其顺手，被誉为“**可执行的伪代码**”。

### 1.3 为什么要学习数据结构？
数据结构是计算机存储、组织数据的方式。如果不学数据结构，你就只是在“写代码”，而不是“设计程序”。

*   **决定程序的效率**
    *   想象你在图书馆找一本书。如果书是**乱堆**在地上的（无结构），你可能要找一天。如果书是按**索引分类**摆放的（有序结构），你只要几分钟。
    *   *案例*: 在 1000 万用户中查找某个 ID。用列表遍历可能要几秒甚至几分钟（如果不凑巧），用字典（Hash）只需要 0.0001 秒。**量级越大，差异越夸张**。
*   **建模现实世界**
    *   现实中的问题通常都有特定的结构。
    *   **排队** -> **队列** (First In First Out)。
    *   **撤销操作 (Ctrl+Z)** -> **栈** (Last In First Out)。
    *   **家族族谱** -> **树**。
    *   **地图导航** -> **图**。
*   **面试与进阶的基石**
    *   所有大厂面试必问数据结构。因为它是程序员的“内功”，决定了你上限在哪里。

> **核心心法**: 程序 = 数据结构 + 算法。Python 已经内置了最强大的几种数据结构（列表、字典、集合），我们要学会的是**在什么场景下选择哪种武器**。


---

## 第二部分：列表 List (1.5 小时)

### 2.1 列表 (List) - Python 的“瑞士军刀”
Python 的列表不仅仅是数组，它是一个功能强大的动态容器。你可以把它理解为**智能变长数组**。

#### 1. 核心特性
*   **有序 (Ordered)**: 元素怎么放进去，就怎么排着（除非你排序）。可以通过索引 `[0]` 访问。
*   **可变 (Mutable)**: 你可以随时在这个容器里增加、删除、修改元素。（这点和字符串不同！）
*   **异构 (Heterogeneous)**: 一个列表里可以同时装整数、字符串，甚至另一个列表。
    *   `my_list = [100, "Python", [1, 2]]`

#### 2. 基础语法速查 (Syntactic Sugar)
```python
# 1. 创建 - 就像去超市拿个空篮子
empty = []        
numbers = [10, 20, 30, 40, 50]

# 2. 索引 (Indexing) - 查单人
print(numbers[0])    # 10 (第一个)
print(numbers[-1])   # 50 (倒数第一个，Python 特有福利)

# 3. 切片 (Slicing) - 查一批人 [开始:结束:步长]
print(numbers[1:4])  # [20, 30, 40] (包头不包尾)
print(numbers[::-1]) # [50, 40, 30, 20, 10] (直接翻转，面试常考)

# 4. 修改
numbers[0] = 999     # [999, 20, ...]

# 5. 常用方法
numbers.append(60)   # 尾部追加
numbers.pop()        # 弹出最后一个
len(numbers)         # 长度
```

### 2.2 内存模型图解 (重要！)
在 Python 中，`a = [1, 2, 3]` 到底发生了什么？
*   **变量名 `a`**: 是一张便利贴（引用）。
*   **列表对象 `[...]`**: 是内存里的一个集装箱。
*   **元素 `1, 2`**: 也是独立的内存对象。列表里存的其实是这些对象的“地址指针”。

**深浅拷贝的坑**:
```python
a = [1, 2, 3]
b = a        # 只是贴了新标签，也没复制箱子
b[0] = 999
print(a)     # [999, 2, 3] -> a 也变了！

# 正确复制 (切片)
c = a[:]     # 咱们买个新箱子，把里面的东西抄过来
```

### 2.3 列表的增删改查 (CRUD) 性能分析
*   **Append (尾部添加)**: 极其快 (O(1))。
*   **Insert (中间插入)**: 非常慢 (O(N))。因为要把插入点后面的所有人都往后挪一位。 

    *   *教学建议*: 尽量避免在长列表的头部插入数据。

### 2.4 列表推导式 (List Comprehension)
这是 Python 最优雅的特性之一。
```python
# 任务: 找出 1-100 里的偶数，并把它们平方
# 旧写法 (4行)
res = []
for i in range(1, 101):
    if i % 2 == 0:
        res.append(i ** 2)

# Pythonic 写法 (1行)
res = [i**2 for i in range(1, 101) if i % 2 == 0]
```

---

## 第三部分：字符串 String (1 小时)

### 3.1 字符串不可变 (Immutable) 的秘密
`s = "hello"`
`s[0] = "H"` ❌ 报错！
*   **为什么设计成不可变？**
    1.  **安全**: 可以放心地把字符串传给函数，不用担心被改坏。
    2.  **效率**: 同样的字符串 "hello" 在内存里只有一份（字符串驻留机制），节省内存。

### 3.2 字符串处理三剑客
1.  **Split & Join** (拆分与缝合):
    *   `tags = "python,ai,bigdata"`
    *   `lst = tags.split(",")` -> `['python', 'ai', 'bigdata']`
    *   `"#".join(lst)` -> `"python#ai#bigdata"`
2.  **Strip** (去皮):
    *   `"  admin  ".strip()` 用来处理用户糟糕的输入。
3.  **Format** (格式化):
    *   `f"Hey {name}, score: {score:.1f}"`

---

## 第四部分：字典 Dictionary (1 小时)

### 4.1 哈希表 (Hash Map) 原理
字典为什么快？
*   **列表查找**: 像一本没有目录的书，找“张三”得一页页翻 (O(N))。
*   **字典查找**: 有目录，直接算出“张三”在哪一页 (O(1))。无论字典有一万条还是一亿条数据，查找速度几乎一样快！

### 4.2 常用操作
```python
student = {"name": "Tony", "score": 98}

# 1. 安全取值
# print(student["age"]) -> 报错 KeyError
print(student.get("age", 18)) -> 没 age 就默认 18

# 2. 遍历
for k, v in student.items():
    print(k, v)
```

### 4.3 什么时候用字典？什么时候用列表？
*   **有序、重复数据** -> 列表 (如：过去10天的气温)。
*   **映射关系、属性数据** -> 字典 (如：身份证号->人，商品ID->价格)。

---

## 第五部分：元组与集合 (0.5 小时)

### 5.1 元组 (Tuple) - 戴手铐的列表
`t = (1, 2)`
*   **场景**: 
    1.  经纬度 `(39.9, 116.4)`，不应该被修改。
    2.  字典的 Key 必须是不可变的，所以列表不能当 Key，但元组可以。

### 5.2 集合 (Set) - 数学工具
`s = {1, 2, 3}`
*   **秒杀面试题**: "给列表去重"。
    `unique_lst = list(set(old_lst))`
*   **关系运算**: 交集 `&`，并集 `|`，差集 `-`。

---

## 第六部分：实战项目 - 班级成绩管理系统 (进阶版) (1 小时)

### 6.1 为什么我们需要复杂的结构？
在真实开发中，需求往往不是简单的“存一个数”。
*   **需求**: 记录全班同学的“期中、期末、高考”三场考试成绩，并且要记录每个人选修了哪些课（物理、历史等）。
*   **痛点**: 如果只用列表 `[85, 92, 78]`，你不仅不知道是谁的，也不知道是哪场考试的。

### 6.2 "完美"的数据结构设计
我们在 PPT 第 13 页展示了一个“终极结构”，它是 Python 数据结构的集大成者。

```python
class_roster = [
    {
        "name": "Alice",
        "id": 1001,
        "exams": {
            "期中": (88, 100),
            "期末": (95, 100), 
            "高考": (650, 750)
        },
        "subjects": {"Math", "English", "Physics"}
    },
    ...
]
```

#### 设计思路解析 (核心教学点)
1.  **最外层为什么用 List `[]`?**
    *   因为学生是**有序**的，我们需要按学号或者录入顺序排队。
    *   我们需要**遍历**全班同学 (`for student in roster`)。

2.  **每个学生为什么用 Dict `{}`?**
    *   因为学生的信息是**多维度**的（姓名、学号、成绩）。
    *   我们需要**通过名字（Key）**快速找到属性，而不是去数索引（`student[0]` 是啥来着？）。

3.  **成绩 `exams` 为什么又是 Dict `{}`?**
    *   考试类型（期中、期末）是**分类标签**，用字典查找最快。
    *   `student["exams"]["高考"]` 这种链式调用非常直观。

4.  **分数 `(88, 100)` 为什么用 Tuple `()`?**
    *   这是数据保护！(得分, 满分) 是一个固定的**事实数据**，不应该被轻易修改（比如不小心把满分改成了 200）。
    *   元组的**不可变性**在这里起到了“只读锁”的作用。

5.  **选课 `subjects` 为什么用 Set `{}`?**
    *   选课列表里**不能有重复**（选两次数学没意义）。
    *   **集合运算**极强：想找“既选了物理又选了历史”的人？直接 `alice["subjects"] & bob["subjects"]` 求交集，一行代码搞定！

### 6.3 课堂互动代码演示
带着学生在控制台敲以下代码，体验“一层层剥洋葱”的感觉：

```python
# 1. 拿到 Alice 这个人
alice = class_roster[0]

# 2. 查她的高考成绩
gk_score = alice["exams"]["高考"]
print(gk_score)  # 输出 (650, 750)

# 3. 算得分率
rate = gk_score[0] / gk_score[1]
print(f"得分率: {rate:.2%}")

# 4. 判断她有没有选物理
if "Physics" in alice["subjects"]:
    print("理科生确认")
```

---

## 第七部分：总结与作业 (0.5 小时)

### 7.1 核心回顾
*   **List**: 排队专用，有序可变。
*   **Dict**: 查字典专用，KV 映射，速度最快。
*   **Tuple**: 封印数据的箱子，只读安全。
*   **Set**: 数学集合，去重 + 关系运算。

### 7.2 课后思考
*   如果我想把所有人的“高考成绩”单独提出来做一个排名，应该怎么写代码？
    *   *提示*: `[s["exams"]["高考"][0] for s in roster]` 配合 `sort()`。
